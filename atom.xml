<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AiXueK&#39;s Site</title>
  
  
  <link href="https://aixuek-itshare.com/atom.xml" rel="self"/>
  
  <link href="https://aixuek-itshare.com/"/>
  <updated>2024-10-24T13:09:02.921Z</updated>
  <id>https://aixuek-itshare.com/</id>
  
  <author>
    <name>AiXue K</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>5.3.2 UE build报错</title>
    <link href="https://aixuek-itshare.com/game-categories/gd-tut/5.3.2-build-error/"/>
    <id>https://aixuek-itshare.com/game-categories/gd-tut/5.3.2-build-error/</id>
    <published>2024-10-24T13:00:27.000Z</published>
    <updated>2024-10-24T13:09:02.921Z</updated>
    
    <content type="html"><![CDATA[<p>在升级完Unreal Engine到版本5.3.2之后，发现即使用UE自带的空Actor Class进行编译都有俩项如下报错：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">========== Build: 46 succeeded, 2 failed, 0 up-to-date, 1 skipped ==========</span><br><span class="line">Done building project “BuildGraph.Automation.csproj” – FAILED.</span><br><span class="line">Done building project “AutomationScripts.Automation.csproj” – FAILED.</span><br></pre></td></tr></table></figure></p><p>解决办法为修改UE的源文件：</p><ol><li>找到安装Unreal Engine Machine的文件夹，我的是<code>D:\App\UnrealEngine Machines\UE_5.3\</code></li><li>到<code>Engine\Source\Programs\AutomationTool\BuildGraph\BgScriptReader.cs</code>中将1640行改为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (users != null)</span><br><span class="line">report.NotifyUsers.<span class="built_in">UnionWith</span>(users);</span><br></pre></td></tr></table></figure></li><li>到<code>Engine/Source/Programs/AutomationTool/Scripts/CheckForHacks.cs</code>中将87行改为：<br><code>Logger.LogInformation(&quot;Scanning files... [&#123;Arg0&#125;]&quot;, FilesToCheck.Count);</code></li></ol><p>即可编译通过。</p><p>后话：</p><p>非常建议开启UE自带的Revision Control功能，这样可以备份自己的游戏项目，同时用自己的硬盘再备份一份。因为如果不小心彻底删掉了<code>.uproject</code>文件，那么似乎就得重新从头做一遍。（我暂时没找到解决方法，如果有知道的大佬麻烦告知 :&gt;~）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在升级完Unreal Engine到版本5.3.2之后，发现即使用UE自带的空Actor Class进行编译都有俩项如下报错：&lt;br&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre</summary>
      
    
    
    
    <category term="IT分类" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/"/>
    
    <category term="游戏开发" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="C++" scheme="https://aixuek-itshare.com/tags/C/"/>
    
    <category term="Game Dev" scheme="https://aixuek-itshare.com/tags/Game-Dev/"/>
    
  </entry>
  
  <entry>
    <title>DFS和BFS</title>
    <link href="https://aixuek-itshare.com/it-categories/code-prac/dfs-bfs/"/>
    <id>https://aixuek-itshare.com/it-categories/code-prac/dfs-bfs/</id>
    <published>2024-08-12T02:59:35.000Z</published>
    <updated>2024-08-24T14:26:51.803Z</updated>
    
    <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>特征</th><th>DFS</th><th>BFS</th></tr></thead><tbody><tr><td>数据结构</td><td>stack</td><td>queue</td></tr><tr><td>储存空间</td><td>只用储存一条路的数值，所以跟高度或者路的长度有关 O(h)，使用空间较少</td><td>每次储存一层的数值，所以是指数增长 O(2^h)，使用空间较多</td></tr><tr><td>常用场景</td><td>不具有最短性</td><td>因为是一层一层地搜索，所以可以最快搜索到<strong>最短路径</strong>(特别是权重为1的时候)</td></tr></tbody></table></div><h1 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h1><p>一条路一直搜索下去，然后后退。</p><p>题目例子：排列数字</p><p>给一个数n，将1~n排成一排，按字典顺序输出所有的排列方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure><p>DFS代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"><span class="type">bool</span> used[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; path[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[i])</span><br><span class="line">        &#123;</span><br><span class="line">            path[level] = i;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(level + <span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">false</span>; <span class="comment">// 回溯恢复</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="宽度优先搜索-BFS"><a href="#宽度优先搜索-BFS" class="headerlink" title="宽度优先搜索 BFS"></a>宽度优先搜索 BFS</h1><p>一层一层搜索。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特征&lt;/th&gt;
&lt;th&gt;DFS&lt;/th&gt;
&lt;th&gt;BFS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;数据结构&lt;/td&gt;
&lt;td&gt;stack</summary>
      
    
    
    
    <category term="IT分类" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/"/>
    
    <category term="代码刷题" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/%E4%BB%A3%E7%A0%81%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="Code" scheme="https://aixuek-itshare.com/tags/Code/"/>
    
    <category term="Algorithm" scheme="https://aixuek-itshare.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>C++面试准备</title>
    <link href="https://aixuek-itshare.com/it-categories/code-prac/C++-interview-prepare/"/>
    <id>https://aixuek-itshare.com/it-categories/code-prac/C++-interview-prepare/</id>
    <published>2024-08-09T01:45:30.000Z</published>
    <updated>2024-08-24T14:26:51.803Z</updated>
    
    <content type="html"><![CDATA[<p>这里是自己搜罗准备的C++面试八股文常用题目，持续更新。</p><ul><li><a href="#static关键字作用">Static关键字作用</a><ul><li><a href="#基本概念">基本概念</a></li><li><a href="#静态数据成员">静态数据成员</a></li><li><a href="#静态成员函数">静态成员函数</a></li></ul></li><li><a href="#extern关键字作用">Extern关键字作用</a></li><li><a href="#指针和引用">指针和引用</a></li><li><a href="#动态库和静态库的区别">动态库和静态库的区别</a></li><li><a href="#虚函数和纯虚函数的区别">虚函数和纯虚函数的区别</a><ul><li><a href="#虚函数">虚函数</a></li><li><a href="#纯虚函数">纯虚函数</a></li></ul></li><li><a href="#友元的应用">友元的应用</a><ul><li><a href="#友元函数">友元函数</a></li><li><a href="#友元类">友元类</a></li></ul></li><li><a href="#bfs与dfs的实现">BFS与DFS的实现</a><ul><li><a href="#bfs-bread-first-search-广度优先搜索">BFS Bread-First Search 广度优先搜索</a></li><li><a href="#dfs">DFS</a></li></ul></li><li><a href="#stl常用容器和算法">STL常用容器和算法</a><ul><li><a href="#list和set">List和Set</a></li><li><a href="#红黑树">红黑树</a></li><li><a href="#二叉搜索数">二叉搜索数</a></li></ul></li><li><a href="#hashmap的原理">HashMap的原理</a></li><li><a href="#堆和栈的区别">堆和栈的区别</a></li><li><a href="#如何解决死锁">如何解决死锁</a></li></ul><hr><h1 id="Static关键字作用"><a href="#Static关键字作用" class="headerlink" title="Static关键字作用"></a>Static关键字作用</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li><p>使用目的：</p><p> 在 C++ 中，需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见时，可将其定义为静态数据。</p></li></ol><ol><li><p>存放位置</p><p> DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。<strong>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化</strong>。</p></li><li><p>使用static的优势：</p><ul><li>可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，<strong>静态数据成员只存储一处，供所有对象共用</strong>。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存。</li><li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。即<strong>静态全局变量不能被其它文件所用</strong>；其它文件中可以定义相同名字的变量，不会发生冲突。</li></ul></li><li><p>动态数据vs静态数据：</p><p>一般程序把新产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。自动变量一般会随着函数的退出而释放空间，<strong>静态数据（即使是函数内部的静态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。</strong></p></li></ol><h2 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h2><p>静态数据成员的生存期大于 class 的对象，静态数据成员是每个 class 有一份，普通数据成员是每个 instance 有一份，因此静态数据成员也叫做类变量，而普通数据成员也叫做实例变量。</p><details>    <summary>Code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 类内的声明只是声明了静态成员变量的存在，类外的定义才真正分配内存并初始化它。</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员变量属于类本身，而不是类的某个实例，因此它们的内存分配和初始化必须在类外进行。</span></span><br><span class="line"><span class="comment">// 在类外初始化时，必须再次指定变量的类型，以确保编译器知道该变量的类型和所属类。</span></span><br><span class="line"><span class="type">int</span> Test::i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test1;</span><br><span class="line">    Test test2;</span><br><span class="line">    test1.i += <span class="number">1</span>;</span><br><span class="line">    test1.n += <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; test2.i &lt;&lt; endl; <span class="comment">// 输出为1</span></span><br><span class="line">    cout &lt;&lt; test2.n &lt;&lt; endl; <span class="comment">// 输出为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>静态成员函数不能访问非静态(包括成员函数和数据成员)，但是非静态可以访问静态。因静态成员函数不属于类实例，它获取不了实例的信息，而非静态成员能获取全局静态数据，所以它可以调用静态数据。</p><details>    <summary>代码示例</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printi</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printn</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Test::i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test1;</span><br><span class="line">    Test test2;</span><br><span class="line">    test1.i += <span class="number">1</span>;</span><br><span class="line">    test1.n += <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; test2.i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; test2.n &lt;&lt; endl;</span><br><span class="line">    test1.<span class="built_in">printi</span>();</span><br><span class="line">    test2.i += <span class="number">1</span>;</span><br><span class="line">    Test::<span class="built_in">printi</span>(); <span class="comment">// 输出为2，因test2也给i加了1</span></span><br><span class="line">    <span class="comment">// Test::printn(); // 报错，因printn得由实例来call</span></span><br><span class="line">    test1.<span class="built_in">printn</span>(); <span class="comment">// 实例call就okay</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="Extern关键字作用"><a href="#Extern关键字作用" class="headerlink" title="Extern关键字作用"></a>Extern关键字作用</h1><ol><li>允许多个文件访问同一个全局变量/函数</li><li>在当前文件表明变量/函数来自于其他文件</li></ol><details>    <summary>代码示例</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file1.cpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">// 声明取的extern的全局变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 会报错，说重复定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl; <span class="comment">// 输出为5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h1><p><a href="https://aixuek-itshare.com/it-categories/dev-record/pointer-and-reference">指针vs引用</a></p><h1 id="动态库和静态库的区别"><a href="#动态库和静态库的区别" class="headerlink" title="动态库和静态库的区别"></a>动态库和静态库的区别</h1><div class="table-container"><table><thead><tr><th>特征</th><th>动态库</th><th>静态库</th></tr></thead><tbody><tr><td>链接时间</td><td>在程序运行时才会被加载，执行文件较小</td><td>在编译链接阶段就已经被加载，所以编译后的可执行文件中就包含了静态库的代码。这样可能导致可执行文件体积过大。</td></tr><tr><td>加载时间</td><td>程序在运行时，动态库需要由操作系统动态加载到内存中，所以时间较长</td><td>静态库在编译中已经存在于可执行文件中，不需要重新加载，时间较快</td></tr><tr><td>更新和维护</td><td>因在运行时才需要加载动态库，所以其他代码文件无需重新编译。比较灵活，但是要保证接口上的兼容性。</td><td>当更新静态库时，因为要重写执行文件，所以需要全部重新编译和链接，较为复杂</td></tr><tr><td>共享性</td><td>多个程序可共享，因为在被动态运行加载时，动态库会被加载到内存中的共享位置，多进程可以同时使用这个区域，从而减少内存使用</td><td>对于静态库，每个使用它的程序都得单独将静态库加入到自己的执行文件中，所以每个程序的副本都是独立的，互不共享。</td></tr><tr><td>常用场景</td><td>- 需要频繁更新迭代的库 <br> - 需要共享库文件</td><td>- 不需要频繁更新的库文件 <br> - 希望将所有的依赖库都放在一个可执行文件中</td></tr></tbody></table></div><h1 id="虚函数和纯虚函数的区别"><a href="#虚函数和纯虚函数的区别" class="headerlink" title="虚函数和纯虚函数的区别"></a>虚函数和纯虚函数的区别</h1><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数的作用是在运行时决定调用哪个类的函数，可以调用派生类中的重写版本，被称为“动态多态”或“运行时多态”。</p><p>虚函数在基类中定义时使用 virtual 关键字，但它有一个函数体（可以是空的），派生类可以选择重写这个函数，也可以不重写而直接使用基类的实现。：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class show function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">child</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Child class show function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *obj = <span class="keyword">new</span> <span class="built_in">child</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出为：Child class show function</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>纯虚函数是一种特殊的虚函数，它在基类中没有具体的实现，只提供一个接口，需要在派生类中实现。</p><p>纯虚函数的定义使用 virtual 关键字，并且在函数声明后使用 = 0 表示它是纯虚函数，没有函数体。如果一个类包含一个或多个纯虚函数，那么这个类就是一个抽象类，不能直接实例化对象。派生类必须实现所有纯虚函数才能被实例化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;     <span class="comment">// 虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class info function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class show function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived class info function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    b-&gt;<span class="built_in">show</span>(); <span class="comment">// 调用的是派生类的实现</span></span><br><span class="line">    b-&gt;<span class="built_in">info</span>(); <span class="comment">// 调用的是派生类的重写版本</span></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="友元的应用"><a href="#友元的应用" class="headerlink" title="友元的应用"></a>友元的应用</h1><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>它可以访问类中所有的成员，包括私有成员和受保护成员。尽管友元函数不是该类的成员函数，但由于被声明为友元（使用<code>friend</code>关键字），因此获得了访问该类内部数据的权限。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> secret;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">secret</span>(val) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">showSecret</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span>; <span class="comment">// 友元函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showSecret</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The secret is: &quot;</span> &lt;&lt; obj.secret &lt;&lt; std::endl; <span class="comment">// 友元函数访问私有成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">showSecret</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用场景</p><ul><li>需要直接访问类的内部成员的情况下，尤其是当多个类之间需要紧密合作时。例如，两个类之间的操作可能需要访问彼此的私有数据。</li><li>操作符重载（如 &lt;&lt; 和 &gt;&gt; 运算符），因为这些运算符通常不能作为成员函数实现。</li></ul><p>友元关系是<strong>单向</strong>的，即如果类 A 将函数 B 声明为友元函数，那么 B 可以访问 A 的私有成员，但反过来 A 并不能访问 B 的私有成员，除非 B 也将 A 声明为友元。</p><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>友元类中的所有成员函数都可以访问另一个类的所有成员（包括私有成员和受保护成员）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> secretA;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> val) : <span class="built_in">secretA</span>(val) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 声明B为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showSecretA</span><span class="params">(A&amp; a)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Secret of A is: &quot;</span> &lt;&lt; a.secretA &lt;&lt; std::endl; <span class="comment">// 访问A的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">objA</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    B objB;</span><br><span class="line">    objB.<span class="built_in">showSecretA</span>(objA); <span class="comment">// 输出为：Secret of A is: 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用场景：</p><ul><li>友元类通常用于两个类之间需要频繁且深度地访问彼此的私有数据的场合<ul><li>复杂数据结构的实现（如链表、树等），其中节点类和容器类可能需要相互访问。</li><li>封装类与管理类之间的紧密协作，例如封装数据的类和处理这些数据的算法类。</li></ul></li><li>友元类可以减少访问器（getter）和设置器（setter）的使用，因为友元类可以直接访问数据。</li></ul><p>友元类的关系是<strong>单向</strong>的，即如果类 A 声明类 B 为友元类，则 B 可以访问 A 的私有成员，但反之 A 不能访问 B 的私有成员，除非 B 也声明 A 为友元类。</p><h1 id="BFS与DFS的实现"><a href="#BFS与DFS的实现" class="headerlink" title="BFS与DFS的实现"></a>BFS与DFS的实现</h1><h2 id="BFS-Bread-First-Search-广度优先搜索"><a href="#BFS-Bread-First-Search-广度优先搜索" class="headerlink" title="BFS Bread-First Search 广度优先搜索"></a>BFS Bread-First Search 广度优先搜索</h2><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h1 id="STL常用容器和算法"><a href="#STL常用容器和算法" class="headerlink" title="STL常用容器和算法"></a>STL常用容器和算法</h1><h2 id="List和Set"><a href="#List和Set" class="headerlink" title="List和Set"></a>List和Set</h2><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h2 id="二叉搜索数"><a href="#二叉搜索数" class="headerlink" title="二叉搜索数"></a>二叉搜索数</h2><h1 id="HashMap的原理"><a href="#HashMap的原理" class="headerlink" title="HashMap的原理"></a>HashMap的原理</h1><p>HashMap通过散列算法使查找、插入、删除接近O(1)的时间复杂度。</p><p>散列函数(Hash Function)负责将拿到的Key映射到不同的哈希值上，而哈希值决定了传入的Key在储存中的位置。一个哈希值便是哈希table的key。</p><p>为了避免发生冲突，即映射到的哈希值已经被分配了变量，当节点到达8时，HashMap会自动变为红黑树。</p><p>最坏的可能性是当N个Key都映射到一个哈希值时，那样映射的值就会一直往后排，所以时间复杂度增加为O(N)。</p><h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><div class="table-container"><table><thead><tr><th>特征</th><th>堆</th><th>栈</th></tr></thead><tbody><tr><td>内存分配方式</td><td>堆由手动分配和释放（<code>new</code>和<code>delete</code>），其内存分配也是动态不连续的，管理和操作更加复杂，速度相对较慢</td><td>栈内存由编译器自动分配和释放，内存分配是连续的，一般以先进后出的方式管理</td></tr><tr><td>储存内容</td><td>需要用于动态分配的大块数据，比如动态数组，复杂数据结构等</td><td>局部变量，函数调用信息，返回地址等系统自动分配的内存</td></tr><tr><td>生命周期</td><td>由程序员控制，生存周期可以跨过函数调用和作用域的限制，如果一直不手动删除，便会一直存在，可能导致内存泄漏</td><td>由函数或代码块的作用域决定，一旦离开作用域，便会自动销毁，内存由系统自动回收</td></tr><tr><td>优缺点</td><td>- 需要动态分配，大小不确定的对象 <br> - 需要手动管理，可能导致内存泄漏 <br> - 相对较慢</td><td>- 生命周期短，且大小固定的变量 <br> - 系统自动管理 <br> - 处理速度快</td></tr></tbody></table></div><h1 id="如何解决死锁"><a href="#如何解决死锁" class="headerlink" title="如何解决死锁"></a>如何解决死锁</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里是自己搜罗准备的C++面试八股文常用题目，持续更新。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#static关键字作用&quot;&gt;Static关键字作用&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#基本概念&quot;&gt;基本概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#静态数据</summary>
      
    
    
    
    <category term="IT分类" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/"/>
    
    <category term="代码刷题" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/%E4%BB%A3%E7%A0%81%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="C++" scheme="https://aixuek-itshare.com/tags/C/"/>
    
    <category term="Interview" scheme="https://aixuek-itshare.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>C++常用设计模式</title>
    <link href="https://aixuek-itshare.com/it-categories/dev-record/C++%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://aixuek-itshare.com/it-categories/dev-record/C++%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-08-03T02:51:54.000Z</published>
    <updated>2024-08-24T14:26:51.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工厂模式-Factory"><a href="#工厂模式-Factory" class="headerlink" title="工厂模式(Factory)"></a>工厂模式(Factory)</h1><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p>只有一个工厂，即一个类负责创建不同类的实例。通常使用static静态方法来创建对象，不需要传递工厂类来创建实例。</p><p>优点：</p><ul><li>单一工厂类，实现简单</li></ul><p>缺点：</p><ul><li>扩展性差，添加新类，新产品时，需要修改工厂类代码</li></ul><p>代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">drive</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 创建纯虚函数，让每个子类实现</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Car</span>() &#123;&#125; <span class="comment">// 析构虚函数，保证子类析构时能正确调用子类析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BydCar</span> : <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drive</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Driving BydCar&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TeslaCar</span> : <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drive</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Driving TeslaCar&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Car* <span class="title">createCar</span><span class="params">(<span class="type">const</span> string&amp; brand)</span> <span class="comment">// 静态创建方法，可随地调用，来避免创建多个类工厂</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (brand == <span class="string">&quot;Byd&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BydCar</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (brand == <span class="string">&quot;Tesla&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TeslaCar</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Car *bydCar = CarFactory::<span class="built_in">createCar</span>(<span class="string">&quot;Byd&quot;</span>);</span><br><span class="line">    bydCar-&gt;<span class="built_in">drive</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> bydCar;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;工厂模式-Factory&quot;&gt;&lt;a href=&quot;#工厂模式-Factory&quot; class=&quot;headerlink&quot; title=&quot;工厂模式(Factory)&quot;&gt;&lt;/a&gt;工厂模式(Factory)&lt;/h1&gt;&lt;h2 id=&quot;简单工厂&quot;&gt;&lt;a href=&quot;#简单工厂&quot; c</summary>
      
    
    
    
    <category term="IT分类" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/"/>
    
    <category term="开发杂记" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/%E5%BC%80%E5%8F%91%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://aixuek-itshare.com/tags/C/"/>
    
    <category term="Code" scheme="https://aixuek-itshare.com/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>SFML C++ 项目</title>
    <link href="https://aixuek-itshare.com/game-categories/gd-tut/SFML-project/"/>
    <id>https://aixuek-itshare.com/game-categories/gd-tut/SFML-project/</id>
    <published>2024-08-02T12:13:41.000Z</published>
    <updated>2024-08-24T14:26:51.802Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#项目简介">项目简介</a></li><li><a href="#项目setup">项目Setup</a></li><li><a href="#项目代码">项目代码</a></li></ul><h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><p>这是一个跟着<a href="https://www.youtube.com/watch?v=UARdwTLUH5U&amp;t=5906s">COMP4300的课程</a>记录制作的项目，因不公开提供代码资料，所以我自己整理了一份方便其他人使用，放在网页上的代码和文档都test过，请放心使用。</p><p>这个项目利用SFML来制作一个含有各种图形四处悬动的窗口，示例如下：</p><p><img src="/images/it-categories/SFML-Ass1示例.png" alt="SFML-Ass1示例"></p><p>要求从config.txt文件中读取窗口大小，生成要求的图形（positionX, positionY, speedX, speedY, r, g, b, (height, width) or radius），图形需要根据自身的速度在窗口中移动，当碰到边框时进行反弹（速度变成相反的），图形需要在正中间显示图形名字：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Window 1280 720</span><br><span class="line">Font fonts/KillerTech.ttf 36 128 128 255</span><br><span class="line">Circle CGreen 100 100 -3 2 0 255 0 50</span><br><span class="line">Circle CBlue 200 200 2 4 0 0 255 100</span><br><span class="line">Circle CPurple 300 300 -2 -1 255 0 255 75</span><br><span class="line">Rectangle RRed 200 200 4 4 255 0 0 50 25</span><br><span class="line">Rectangle RGrey 300 250 -2 2 100 100 100 50 100</span><br><span class="line">Rectangle RTeal 25 100 -2 -2 0 255 255 100 100</span><br></pre></td></tr></table></figure></p><h1 id="项目Setup"><a href="#项目Setup" class="headerlink" title="项目Setup"></a>项目Setup</h1><ol><li>下载SFML，官网：<a href="https://www.sfml-dev.org/download.php">https://www.sfml-dev.org/download.php</a></li><li>下载Visual Studio 2022，官网：<a href="https://visualstudio.microsoft.com/downloads/">https://visualstudio.microsoft.com/downloads/</a></li><li>将SFML路径添加到系统环境变量中<ol><li>将下载好的<code>SFML-2.6.1</code>放到<code>C:\lib\</code>中（要自己新建文件夹）</li><li>新建变量<code>SFML_DIR</code>: <code>C:\lib\SFML-2.6.1</code></li><li>在path变量中添加：<code>%SFML_DIR%\bin</code>, <code>%SFML_DIR%\include</code></li></ol></li><li>在visual studio 2022中创建一个项目</li><li>跟随官网配置project settings: <a href="https://www.sfml-dev.org/tutorials/2.6/start-vc.php，这步是让Visual">https://www.sfml-dev.org/tutorials/2.6/start-vc.php，这步是让Visual</a> Studio知道SFML在哪里可以找到</li><li>在项目所在的文件夹中，创建一个新文件夹<code>fonts</code>，并下载一个ttf font文件放入其中（我在这里找的免费font：<a href="https://www.1001freefonts.com/）">https://www.1001freefonts.com/）</a></li></ol><p>可以去我的<a href="https://github.com/AiXueK/COMP4300-Game-Programming/tree/SERGEANT/COMP4300-Ass1">github COMP4300项目</a>中查看文件夹结构，或直接下载所需文件</p><h1 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h1><p>如果想自己先写写试试的话，可以从以下的Sample Code入手，同时，也可以用以下代码来检测Setup是否成功。这个代码包含基本的窗口、文字和一个移动的圆形。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SFML/Graphics.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create a window</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> wWidth = <span class="number">640</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> wHeight = <span class="number">480</span>;</span><br><span class="line">    <span class="function">sf::RenderWindow <span class="title">window</span><span class="params">(sf::VideoMode(wWidth, wHeight), <span class="string">&quot;SFML Works&quot;</span>)</span></span>; <span class="comment">// render a window in video type</span></span><br><span class="line">    window.<span class="built_in">setFramerateLimit</span>(<span class="number">60</span>); <span class="comment">// limit the screen frame rate at 60 per second</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> g = <span class="number">255</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw shapes</span></span><br><span class="line">    <span class="function">sf::CircleShape <span class="title">circle</span><span class="params">(<span class="number">50</span>)</span></span>; <span class="comment">// circle with radius of 50</span></span><br><span class="line">    circle.<span class="built_in">setFillColor</span>(sf::<span class="built_in">Color</span>(r, g, b));</span><br><span class="line">    circle.<span class="built_in">setPosition</span>(<span class="number">300.0f</span>, <span class="number">300.0f</span>); <span class="comment">// set top left position of the shape</span></span><br><span class="line">    <span class="type">float</span> circleSpeed = <span class="number">1.0f</span>; <span class="comment">// 1.0f per frame</span></span><br><span class="line"></span><br><span class="line">    sf::Font font;</span><br><span class="line">    <span class="keyword">if</span> (!font.<span class="built_in">loadFromFile</span>(<span class="string">&quot;fonts/FreshMulberryDemoRegular.ttf&quot;</span>)) <span class="comment">// if it returns true, nothing happens</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Could not load font.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up text object</span></span><br><span class="line">    <span class="function">sf::Text <span class="title">text</span><span class="params">(<span class="string">&quot;Sample Text&quot;</span>, font, <span class="number">24</span>)</span></span>; <span class="comment">// set up text string, font and character size</span></span><br><span class="line">    text.<span class="built_in">setPosition</span>(<span class="number">0</span>, wHeight - (<span class="type">float</span>)text.<span class="built_in">getCharacterSize</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up the main loop to keep the window open</span></span><br><span class="line">    <span class="keyword">while</span> (window.<span class="built_in">isOpen</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Set up the supervision of the window event</span></span><br><span class="line">        sf::Event event;</span><br><span class="line">        <span class="keyword">while</span> (window.<span class="built_in">pollEvent</span>(event))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (event.type == sf::Event::Closed)</span><br><span class="line">            &#123;</span><br><span class="line">                window.<span class="built_in">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (event.type == sf::Event::KeyPressed)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Key pressed with code = &quot;</span> &lt;&lt; event.key.code &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (event.key.code == sf::Keyboard::D)</span><br><span class="line">                &#123;</span><br><span class="line">                    circleSpeed *= <span class="number">-1.0F</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update new shape position per frame</span></span><br><span class="line">        <span class="type">float</span> speedX = <span class="number">0.5</span>;</span><br><span class="line">        <span class="type">float</span> speedY = <span class="number">2.0</span>;</span><br><span class="line">        circle.<span class="built_in">setPosition</span>(circle.<span class="built_in">getPosition</span>().x + circleSpeed, circle.<span class="built_in">getPosition</span>().y + speedY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw &amp; Render window</span></span><br><span class="line">        window.<span class="built_in">clear</span>(); <span class="comment">// clear what&#x27;s left in the previous frame</span></span><br><span class="line">        window.<span class="built_in">draw</span>(circle);</span><br><span class="line">        window.<span class="built_in">draw</span>(text);</span><br><span class="line">        window.<span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#项目简介&quot;&gt;项目简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#项目setup&quot;&gt;项目Setup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#项目代码&quot;&gt;项目代码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;项目简介&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="IT分类" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/"/>
    
    <category term="游戏开发" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="C++" scheme="https://aixuek-itshare.com/tags/C/"/>
    
    <category term="Game Dev" scheme="https://aixuek-itshare.com/tags/Game-Dev/"/>
    
  </entry>
  
  <entry>
    <title>函数指针</title>
    <link href="https://aixuek-itshare.com/it-categories/dev-record/func-pointer/"/>
    <id>https://aixuek-itshare.com/it-categories/dev-record/func-pointer/</id>
    <published>2024-07-27T03:59:40.000Z</published>
    <updated>2024-08-24T14:26:51.804Z</updated>
    
    <content type="html"><![CDATA[<p>函数指针是指向函数的指针，跟指向变量的指针没差。</p><p>函数的一个属性就是其地址指明了函数体在内存中的位置，在调用函数时，系统将控制权给这个位置来执行函数。</p><p>用一个函数来举例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>f</code>是指向函数<code>f()</code>的指针，<code>*f()</code>是函数本身， <code>(*f)(7)</code>是调用这个函数并取得值，其本质跟<code>f(7)</code>没有任何差别，只是在大多数编程语言中（包括 C 和 C++），编译器会自动理解<code>f</code>是一个函数指针并进行适当的解引用。</p><p>函数指针一般在需要函数作为一个变量的时候起到作用，即函数作为参数传递，如当要求n到m之间用函数f的总和时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(<span class="type">double</span> (*f)(<span class="type">double</span>), <span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt;= m ; ++i)</span><br><span class="line">        result += <span class="built_in">f</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里，<code>double (*f)(double)</code>是指<code>f</code>为指向一个返回<code>double</code>，输入值为<code>double</code>的函数指针，那么实际上传入的function就可以是满足输入和输出的多变的模式，极大地提高了灵活性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">square</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cube</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">identity</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 三种不同的function都可以被当作参数传递进去</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum of squares from 1 to 3: &quot;</span> &lt;&lt; <span class="built_in">sum</span>(square, <span class="number">1</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum of cubes from 1 to 3: &quot;</span> &lt;&lt; <span class="built_in">sum</span>(cube, <span class="number">1</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum of identity from 1 to 3: &quot;</span> &lt;&lt; <span class="built_in">sum</span>(identity, <span class="number">1</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拓展来说，<code>double *f(double)</code>则是一个函数声明，表示 f 是一个函数，它接受一个 double 类型的参数，并返回一个<em>指向double类型的指针</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span>* <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span>* result = <span class="keyword">new</span> <span class="built_in">double</span>(x * <span class="number">2</span>); <span class="comment">// 动态分配一个 double 并将其值设置为 x 的两倍</span></span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回的是一个指向double这个值的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> value = <span class="number">5.0</span>;</span><br><span class="line">    <span class="type">double</span>* result = <span class="built_in">f</span>(value); <span class="comment">// 定义一个double指针</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; *result &lt;&lt; std::endl; <span class="comment">// 输出指针指向的值，解引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> result; <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以<code>double (*f)(double)</code>代表的是一个指向返回double，输入为double的函数指针。函数指针可以让函数作为参数被灵活地使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;函数指针是指向函数的指针，跟指向变量的指针没差。&lt;/p&gt;
&lt;p&gt;函数的一个属性就是其地址指明了函数体在内存中的位置，在调用函数时，系统将控制权给这个位置来执行函数。&lt;/p&gt;
&lt;p&gt;用一个函数来举例&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="IT分类" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/"/>
    
    <category term="开发杂记" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/%E5%BC%80%E5%8F%91%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://aixuek-itshare.com/tags/C/"/>
    
    <category term="Code" scheme="https://aixuek-itshare.com/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>指针vs引用</title>
    <link href="https://aixuek-itshare.com/it-categories/dev-record/pointer-and-reference/"/>
    <id>https://aixuek-itshare.com/it-categories/dev-record/pointer-and-reference/</id>
    <published>2024-07-25T14:51:31.000Z</published>
    <updated>2024-08-24T14:26:51.804Z</updated>
    
    <content type="html"><![CDATA[<p>指针：</p><ul><li>指向值，但本身值为地址。</li><li>可以有null pointer，指向特殊地址0</li><li>初始化后可以被改变</li></ul><p>引用：</p><ul><li>相当于const指针，<code>int&amp; r = n</code>等同于<code>int *const r = &amp;n</code></li><li>因为是<code>int *const</code>所以初始化之后，r本身的值不能改变，也就是不能改变它指向的地址了</li></ul><p>关于<code>int *const r</code>:</p><ul><li>表示一个常量指针，指向一个整数。</li><li>指针是常量：一旦初始化，指针本身的值（即它指向的地址）不能改变。</li><li>指向的数据是可变的：可以通过这个指针修改它指向的整数的值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> value2 = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> ptr = &amp;value1; <span class="comment">// 常量指针，指向 value1，可以将const后面的(ptr)单独看，它是指针本身，所以是指针本身不能变，也就是ptr所储存的地址不能变</span></span><br><span class="line"></span><br><span class="line">*ptr = <span class="number">15</span>; <span class="comment">// 这是可以的，因为可以修改指针指向的数据，所以也可以更改被引用的变量的值</span></span><br><span class="line"><span class="comment">// ptr = &amp;value2; // 报错，因为不能修改指针本身的值</span></span><br></pre></td></tr></table></figure><p>相应的有<code>const int *</code>：</p><ul><li>表示一个指向常量整数的指针。</li><li>指针是可变的：指针本身的值（即它指向的地址）可以改变。</li><li>指向的数据是常量：不能通过这个指针修改它指向的整数的值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> value2 = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr = &amp;value1; <span class="comment">// 指向常量整数的指针，可以将(int *ptr)看作一个整体，它代表的是指针指向的值，所以是指向的值不能改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// *ptr = 15; // 报错，因为不能修改指针指向的数据</span></span><br><span class="line">ptr = &amp;value2; <span class="comment">// 这是可以的，因为可以改变指针本身的值</span></span><br></pre></td></tr></table></figure><p>所以，引用的作用就是一个常量指针，它经常被用于函数中传递数据来节省单独copy一次的空间，或者当函数执行的过程中，参数需要永久被改变，就可以通过引用来传递参数（因为它是通过地址来获取值，所以更改引用的值，就是在地址上更改值，而不是更改复制的值）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;指针：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指向值，但本身值为地址。&lt;/li&gt;
&lt;li&gt;可以有null pointer，指向特殊地址0&lt;/li&gt;
&lt;li&gt;初始化后可以被改变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;引用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相当于const指针，&lt;code&gt;int&amp;amp</summary>
      
    
    
    
    <category term="IT分类" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/"/>
    
    <category term="开发杂记" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/%E5%BC%80%E5%8F%91%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://aixuek-itshare.com/tags/C/"/>
    
    <category term="Code" scheme="https://aixuek-itshare.com/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>复制构造函数</title>
    <link href="https://aixuek-itshare.com/it-categories/dev-record/copy-constructor/"/>
    <id>https://aixuek-itshare.com/it-categories/dev-record/copy-constructor/</id>
    <published>2024-07-25T14:02:32.000Z</published>
    <updated>2024-08-24T14:26:51.804Z</updated>
    
    <content type="html"><![CDATA[<p>复制构造函数的用途就是解决：当将数据从一个对象复制到另一个对象时，其中的指针数据成员没有被正确处理的情况。</p><p>如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">char</span> *n=<span class="string">&quot; &quot;</span>, <span class="type">int</span> a = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="built_in">strdup</span>(n); <span class="comment">// strdup是用来分配一个新的内存并返回该指向该字符串的指针</span></span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当这样带<code>char *name</code>指针的对象，经历复制时，会遇到以下问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">node1</span><span class="params">(<span class="string">&quot;node1&quot;</span>, <span class="number">10</span>)</span></span>; <span class="comment">// Create object node1</span></span><br><span class="line"><span class="function">Node <span class="title">node2</span><span class="params">(node1)</span></span>; <span class="comment">// Create a node1 copy named node, 同样可写为： Node node2 = node1;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(node2.name, <span class="string">&quot;changedName&quot;</span>); <span class="comment">// 将node2的name改为&quot;changedName&quot;</span></span><br><span class="line">node2.age = <span class="number">30</span>; <span class="comment">// 将node2的age改为30</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;node1.name = %s, node1.age = %d\n&quot;</span>, node1.name, node1.age);</span><br><span class="line"><span class="comment">// 输出是 node1.name = changedName, node1.age = 10</span></span><br></pre></td></tr></table></figure><p>这里<code>node1.name</code>的值跟<code>node2.name</code>的值一样，是因为Node这个struct没有定义<em>复制构造函数</em>，导致编译器自己生成了复制构造函数。生成的复制构造函数只是逐个对成员进行复制，所以它将<code>char *name</code>上面指向name字符串的指针值，即地址，复制给了node2，而不是在地址上的字符串的值。而因为age本身就是一个值，所以没被影响。</p><p>所以这里需要创建复制构造函数来解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">char</span> *n=<span class="string">&quot; &quot;</span>, <span class="type">int</span> a = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="built_in">strdup</span>(n); <span class="comment">// strdup是用来分配一个新的内存并返回该指向该字符串的指针</span></span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建复制构造函数</span></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">const</span> Node&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="built_in">strdup</span>(n.name); <span class="comment">// 用strdup来分配新内存，储存新的指针来避免只复制指向同一个地址的指针</span></span><br><span class="line">        age = n.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样node1, node2之间就不会有相互影响的问题。</p><p>同样，为了完全杜绝此类问题发生，还需<em>重载复制运算符</em>来应对<code>node1 = node2</code>这种复制方式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Node&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Node&amp; n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;n) <span class="comment">// 避免自己=自己还多走一步, this是一个指向自己（调用这个函数的调用对象）的指针，比如 a = b，调用对象就是a</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="number">0</span>) <span class="comment">// 不为特殊地址/空地址</span></span><br><span class="line">            <span class="built_in">free</span>(name); <span class="comment">// 将指向的地址free掉</span></span><br><span class="line">        name = <span class="built_in">strdup</span>(n.name); <span class="comment">// 来储存新的字符串地址</span></span><br><span class="line">        age = n.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以当对象包含指针数据时，需要同时加上<em>复制构造函数</em>以及<em>重载=运算符</em>，这样所有情况就都解决了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;复制构造函数的用途就是解决：当将数据从一个对象复制到另一个对象时，其中的指针数据成员没有被正确处理的情况。&lt;/p&gt;
&lt;p&gt;如：&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    <category term="IT分类" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/"/>
    
    <category term="开发杂记" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/%E5%BC%80%E5%8F%91%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://aixuek-itshare.com/tags/C/"/>
    
    <category term="Code" scheme="https://aixuek-itshare.com/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>双指针算法</title>
    <link href="https://aixuek-itshare.com/it-categories/code-prac/two-pointers/"/>
    <id>https://aixuek-itshare.com/it-categories/code-prac/two-pointers/</id>
    <published>2024-07-07T13:21:05.000Z</published>
    <updated>2024-08-24T14:26:51.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><p>主要思想：</p><p>帮助优化双循环算法，原本算法为O(n^2)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br></pre></td></tr></table></figure><p>可以将算法优化为O(n)，此时双指针就像弹簧一样，i在前面扯着j往前移动，然后check它们中间那一段是否合格：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j++;</span><br></pre></td></tr></table></figure><h2 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h2><p>给一个字符串，单词用空格隔开，输出每个单词</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string input;</span><br><span class="line">    <span class="built_in">getline</span>(cin, input);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; input[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// mark the space as the end of the word</span></span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; input.<span class="built_in">size</span>() &amp;&amp; input[j] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            j++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; ++k)</span><br><span class="line">            cout &lt;&lt; input[k];</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长连续不重复子序列"><a href="#最长连续不重复子序列" class="headerlink" title="最长连续不重复子序列"></a>最长连续不重复子序列</h2><p>给定一个长度为n的整数序列，请找出最长的不包含重复数字的连续子序列，输出它的长度。</p><p>输入：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 2 3 5</span><br></pre></td></tr></table></figure></p><p>输出：3 (2, 3, 5)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100000</span>;</span><br><span class="line"><span class="type">int</span> q[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s[q[i]]++;</span><br><span class="line">        <span class="keyword">while</span> (s[q[i]] &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[q[j]]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">max</span>(result, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;双指针算法&quot;&gt;&lt;a href=&quot;#双指针算法&quot; class=&quot;headerlink&quot; title=&quot;双指针算法&quot;&gt;&lt;/a&gt;双指针算法&lt;/h1&gt;&lt;p&gt;主要思想：&lt;/p&gt;
&lt;p&gt;帮助优化双循环算法，原本算法为O(n^2)：&lt;/p&gt;
&lt;figure class=&quot;hig</summary>
      
    
    
    
    <category term="IT分类" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/"/>
    
    <category term="代码刷题" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/%E4%BB%A3%E7%A0%81%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="Code" scheme="https://aixuek-itshare.com/tags/Code/"/>
    
    <category term="Algorithm" scheme="https://aixuek-itshare.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>经典笔试刷题集合</title>
    <link href="https://aixuek-itshare.com/it-categories/code-prac/code-ass/"/>
    <id>https://aixuek-itshare.com/it-categories/code-prac/code-ass/</id>
    <published>2024-07-06T03:01:11.000Z</published>
    <updated>2024-08-24T14:26:51.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="牛客-HJ17-坐标移动（中等）"><a href="#牛客-HJ17-坐标移动（中等）" class="headerlink" title="牛客 HJ17 坐标移动（中等）"></a>牛客 HJ17 坐标移动（中等）</h1><p>开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。</p><p>输入：</p><p>合法坐标为A(或者D或者W或者S) + 数字（两位以内），坐标之间以;分隔。（如：A10;S20;W10;D30;X;A1A;B10A11;;A10;）</p><p>非法坐标点需要进行丢弃。如AA10;  A1A;  $%$;  YAD; 等。</p><p>起点（0,0），A10   =  （-10,0），S20   =  (-10,-20)</p><p>数据范围：1 &lt;= n &lt;= 10000</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;牛客-HJ17-坐标移动（中等）&quot;&gt;&lt;a href=&quot;#牛客-HJ17-坐标移动（中等）&quot; class=&quot;headerlink&quot; title=&quot;牛客 HJ17 坐标移动（中等）&quot;&gt;&lt;/a&gt;牛客 HJ17 坐标移动（中等）&lt;/h1&gt;&lt;p&gt;开发一个坐标计算工具， A表</summary>
      
    
    
    
    <category term="IT分类" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/"/>
    
    <category term="代码刷题" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/%E4%BB%A3%E7%A0%81%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="Code" scheme="https://aixuek-itshare.com/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>参加SIG event day的搞笑事情</title>
    <link href="https://aixuek-itshare.com/personal/funny-experience/sig-event/"/>
    <id>https://aixuek-itshare.com/personal/funny-experience/sig-event/</id>
    <published>2024-06-29T04:13:46.000Z</published>
    <updated>2024-08-24T14:26:51.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在通过SIG的笔试、HR电话面试之后（有关SIG的面试题和面试经历，请看<a href="/it-categories/interviews/sig-interview">SIG面试</a>），收到了参加SIG办公室俩天参观的邀请，于是开开心心就去了，毕竟美国大投行公司，它的财力对我吸引力是非常大的，也很好奇有钱公司内部长啥样。也就开启了俩天的social娱乐。</p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>SIG的参观活动包括：刚开始的破冰，大家一起吃早餐（白人早餐真的一般，但是咖啡和面包还是不错的），一群人一起坐个大桌子，一起聊天，然后会有HR工作人员到每个桌子参与聊天（纯闲聊，之前正值Taylor Swift在悉尼开了个演唱会，而且那个HR是粉丝，于是这个成为了主要话题）。</p><p>结束之后开始由团队做演讲，介绍公司、投行、公司团队结构和负责的事情，有提问环节，在介绍Trading思想时，也会插入跟股票相关的卡牌游戏环节，来方便理解。当然，之后还有赌博游戏，因为SIG这个公司的赌博文化很重，每年还会举行赌博游戏WIZARD的比赛（包含奖金的那种:&gt;）。</p><p>第一天晚上，因为SIG把住宿和路费都包了，很豪华的酒店，就在悉尼歌剧院海湾附近的高楼里面，听住进去的人说晚上的夜景灯光非常漂亮，房间也很豪华（瞬间后悔为啥我要写我住悉尼），所以我们都参加了晚上的酒吧晚餐。酒吧是crown顶楼的露台，非常豪华！（又是豪华，我知道，这就是财力的魅力啊）。SIG的it老员工和第二天带我们的员工组长都会来一起聊天（就是试水感觉，看看你做了啥项目，擅长什么，沟通怎么样），我和之前聊天的大佬也一起聊项目，一起问他们一些之后工作的问题和他们对it的看法啥的。在屋顶上边聊天边喝酒吃小burger，第一次体验服务员轮流托着餐盘一个个服务的感觉挺新奇舒适的。</p><p>第一天结束后，第二天就多了一个题目分析。在这个event之前，SIG会发一个题目邮件，要求在来event前做完。所以第二天员工team leader就会带着自己的组员一起把每个人写的题解放到屏幕上讲解分析，有什么缺点，什么有点，为什么错，现场优化。这就是贼有趣的事情发生的时候了（后面些写）。之后，员工带着我们参观了各种办公区，SIG的办公区属于黑色简约风，黑色的地毯，清爽大气的办公桌，加上落地窗外明朗开阔的风景，简直是我的梦中情office！</p><p>在第二天结束末尾，大家一起拍了合照，领了纪念礼包（喜欢它送到WIZARD卡牌哈哈），就欢快地结束了。</p><h2 id="有趣事件1"><a href="#有趣事件1" class="headerlink" title="有趣事件1"></a>有趣事件1</h2><p>关于代码一起分析那事儿，铺垫挺长的。在第一天晚上酒吧聊天地时候，就有一个白女不停地说，“哎呀，有的时候我的灵感一会儿就来了，我喜欢深夜写码，但有时候写完之后第二天就忘了怎么写的，很惊讶我自己能写出来，真的有趣哈哈。”</p><p>我其实也喜欢大晚上写，可能一部分码农都有这个习惯吧，特别熬夜的时候如何喝酒提神的话（我会这样，很爽哈哈），有的时候确实会再次看到代码有点懵，啊这咋写的。而且我在写完代码一周之后，大概率会忘记我的逻辑和干的事情，所以我一直需要记笔记，记录这个代码重点干了啥，逻辑是怎么样的（之前实习的时候，就因为我忘记我写的代码的逻辑，而被mentor问这是我写的代码吗:&lt;…）。</p><p>所以我理解她说的话，可能说得夸张了一点，但是是可能存在的，但是我不理解为啥她逢人就讲，难不成这是优势？自动清缓存让脑子更灵光？但是第二天，我就理解了。</p><p>当时正巧第二天我跟那个白女在一个组，这个代码题，就我和她写出了全部的解，有另俩个女生卡在了最后一个test，time limit上，还有一个女生有bug，只过了一部分test。于是工作人员在分析完其他人的代码，就让我和她讲讲解题思路。当时我还有点小私心：她在我前面（按顺序一个一个讲），那她把思路讲完了，我就是透明了。随后我发现这个完全多余，因为她直接搬出了“啊呀，我有时候晚上写码blablabla…我忘了咋做的”，mentor一听，就直接问我你来讲讲？</p><p>于是我意味深长地看了她一眼（因为昨晚她挺跳的，除了说她忘代码的事儿，还不停地说她自己的项目，多么多么厉害啥的），如果她只是抄了代码我无所谓，但是又抄代码又要跳说自己多厉害就有点讨厌了。然后到白板讲了解题思路。之后小组的人不理解的也是找我问思路，都不问她。所以嘛，小聪明少耍，大家都懂。</p><p>后来想来挺搞笑的，铺垫了一晚上，也不回去查一查捣鼓下解题思路，还期望第二天能混过去呢，原来有的白女跟普信男一样，老装了。</p><h2 id="有趣事件2"><a href="#有趣事件2" class="headerlink" title="有趣事件2"></a>有趣事件2</h2><p>这个event本身就挺drama，但也挺合乎常理吧。在第一天开始的时候，SIG团队的工作人员就不停强调“这不是面试中的一环，大家敞开心扉玩，就是互相熟悉熟悉介绍介绍，不要太紧张”。结果我知道一同去参加的一个好友，在这个event之后就给刷了 :&lt;???。我当时听这个话一开始是嗤之以鼻“谁特么信啊”，之后听SIG说了好几次，给我洗脑了：开开心心玩，谁会用这个来评估，有时候玩游戏的时候也没咋看工作人员观察，于是自己开开心心和大佬沉浸在解方块puzzle中，当时一群人在旁边问工作人员面试问题。。。每想到结果还是会刷人。。。，而且当时我都那样都没被刷。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>在里面遇到了很多有趣的人，有在玩WIZARD一直负分的女生，可可爱爱地向马上让她再次输分的人撒娇说“不要，让我赢一盘嘛，求你了”，有C++大佬谦虚地说我没那么厉害的同时给我展示了他们在做的贼大的开源服务，还有一个眼睛亮闪闪的女生认真地看着我说这个解法很棒…</p><p>这些真诚有趣的人都是比这个event更加令人深刻、有意义的回忆，一直期待遇到更多有趣的人。虽然之后SIG后面几面挂了，但是让我记住了：哇，有钱就是np！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在通过SIG的笔试、HR电话面试之后（有关SIG的面试题和面试经历，请看&lt;a href=&quot;/it-categories/interviews</summary>
      
    
    
    
    <category term="个人" scheme="https://aixuek-itshare.com/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    <category term="有趣轶事" scheme="https://aixuek-itshare.com/categories/%E4%B8%AA%E4%BA%BA/%E6%9C%89%E8%B6%A3%E8%BD%B6%E4%BA%8B/"/>
    
    
    <category term="搞笑" scheme="https://aixuek-itshare.com/tags/%E6%90%9E%E7%AC%91/"/>
    
  </entry>
  
  <entry>
    <title>有趣轶事</title>
    <link href="https://aixuek-itshare.com/personal/funny-experience/index/"/>
    <id>https://aixuek-itshare.com/personal/funny-experience/index/</id>
    <published>2024-06-29T04:13:46.000Z</published>
    <updated>2024-08-24T14:26:51.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有趣轶事"><a href="#有趣轶事" class="headerlink" title="有趣轶事"></a>有趣轶事</h1><h2 id="参加SIG-event-day的搞笑事情"><a href="#参加SIG-event-day的搞笑事情" class="headerlink" title="参加SIG event day的搞笑事情"></a><a href="https://aixuek-itshare.com/personal/funny-experience/sig-event">参加SIG event day的搞笑事情</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;有趣轶事&quot;&gt;&lt;a href=&quot;#有趣轶事&quot; class=&quot;headerlink&quot; title=&quot;有趣轶事&quot;&gt;&lt;/a&gt;有趣轶事&lt;/h1&gt;&lt;h2 id=&quot;参加SIG-event-day的搞笑事情&quot;&gt;&lt;a href=&quot;#参加SIG-event-day的搞笑事情&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面试过往</title>
    <link href="https://aixuek-itshare.com/it-categories/interviews/index/"/>
    <id>https://aixuek-itshare.com/it-categories/interviews/index/</id>
    <published>2024-06-28T09:18:28.000Z</published>
    <updated>2024-08-24T14:26:51.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试过往"><a href="#面试过往" class="headerlink" title="面试过往"></a>面试过往</h1><h2 id="C-面试问题"><a href="#C-面试问题" class="headerlink" title="C++面试问题"></a><a href="https://aixuek-itshare.com/it-categories/interviews/C++-interview-questions">C++面试问题</a></h2><h2 id="SIG-grad-tech面试的分享"><a href="#SIG-grad-tech面试的分享" class="headerlink" title="SIG grad tech面试的分享"></a><a href="https://aixuek-itshare.com/it-categories/interviews/sig-interview">SIG grad tech面试的分享</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面试过往&quot;&gt;&lt;a href=&quot;#面试过往&quot; class=&quot;headerlink&quot; title=&quot;面试过往&quot;&gt;&lt;/a&gt;面试过往&lt;/h1&gt;&lt;h2 id=&quot;C-面试问题&quot;&gt;&lt;a href=&quot;#C-面试问题&quot; class=&quot;headerlink&quot; title=&quot;C++面试</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++笔记</title>
    <link href="https://aixuek-itshare.com/it-categories/dev-record/C++-notes/"/>
    <id>https://aixuek-itshare.com/it-categories/dev-record/C++-notes/</id>
    <published>2024-06-28T07:45:31.000Z</published>
    <updated>2024-09-07T12:25:14.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Static关键字作用"><a href="#Static关键字作用" class="headerlink" title="Static关键字作用"></a>Static关键字作用</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li><p>使用目的：</p><p> 在 C++ 中，需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见时，可将其定义为静态数据。</p></li></ol><ol><li><p>存放位置</p><p> DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。<strong>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化</strong>。</p></li><li><p>使用static的优势：</p><ul><li>可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，<strong>静态数据成员只存储一处，供所有对象共用</strong>。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存。</li><li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。即<strong>静态全局变量不能被其它文件所用</strong>；其它文件中可以定义相同名字的变量，不会发生冲突。</li></ul></li><li><p>动态数据vs静态数据：</p><p>一般程序把新产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。自动变量一般会随着函数的退出而释放空间，<strong>静态数据（即使是函数内部的静态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。</strong></p></li></ol><h2 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h2><p>静态数据成员的生存期大于 class 的对象，静态数据成员是每个 class 有一份，普通数据成员是每个 instance 有一份，因此静态数据成员也叫做类变量，而普通数据成员也叫做实例变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 类内的声明只是声明了静态成员变量的存在，类外的定义才真正分配内存并初始化它。</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员变量属于类本身，而不是类的某个实例，因此它们的内存分配和初始化必须在类外进行。</span></span><br><span class="line"><span class="comment">// 在类外初始化时，必须再次指定变量的类型，以确保编译器知道该变量的类型和所属类。</span></span><br><span class="line"><span class="type">int</span> Test::i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test1;</span><br><span class="line">    Test test2;</span><br><span class="line">    test1.i += <span class="number">1</span>;</span><br><span class="line">    test1.n += <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; test2.i &lt;&lt; endl; <span class="comment">// 输出为1</span></span><br><span class="line">    cout &lt;&lt; test2.n &lt;&lt; endl; <span class="comment">// 输出为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>静态成员函数不能访问非静态(包括成员函数和数据成员)，但是非静态可以访问静态。因静态成员函数不属于类实例，它获取不了实例的信息，而非静态成员能获取全局静态数据，所以它可以调用静态数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printi</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printn</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Test::i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test1;</span><br><span class="line">    Test test2;</span><br><span class="line">    test1.i += <span class="number">1</span>;</span><br><span class="line">    test1.n += <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; test2.i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; test2.n &lt;&lt; endl;</span><br><span class="line">    test1.<span class="built_in">printi</span>();</span><br><span class="line">    test2.i += <span class="number">1</span>;</span><br><span class="line">    Test::<span class="built_in">printi</span>(); <span class="comment">// 输出为2，因test2也给i加了1</span></span><br><span class="line">    <span class="comment">// Test::printn(); // 报错，因printn得由实例来call</span></span><br><span class="line">    test1.<span class="built_in">printn</span>(); <span class="comment">// 实例call就okay</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h2><p>实现局部能一直使用一个静态变量，而其他域不能访问的静态变量。</p><p>比如，记录一个函数被调用了多少次：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>; <span class="comment">// 这里就将num放到了静态区，所以不会被局部域销毁;初始赋值只会被执行一次</span></span><br><span class="line">    ++num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;called %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">count</span>(); <span class="comment">// called 1</span></span><br><span class="line">    <span class="built_in">count</span>(); <span class="comment">// called 2</span></span><br><span class="line">    <span class="built_in">count</span>(); <span class="comment">// called 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h2><p>限制全局变量的获取权限，只让当前文件访问，不让其他文件访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1</span></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> b; <span class="comment">// 成功</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a; <span class="comment">// 报错显示找不到a，因为file1中的a是静态的，其他文件访问不到</span></span><br></pre></td></tr></table></figure><h1 id="Extern关键字作用"><a href="#Extern关键字作用" class="headerlink" title="Extern关键字作用"></a>Extern关键字作用</h1><ol><li>允许多个文件访问同一个全局变量/函数</li><li>在当前文件表明变量/函数来自于其他文件</li><li>外来函数默认在外面找，不用extern关键字</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">5</span>, j = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file1.cpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i, j; <span class="comment">// 声明取的extern的全局变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 会报错，说重复定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; <span class="comment">// 只用声明一下add函数，不需要extern关键字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl; <span class="comment">// 输出为5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;add result: %d\n&quot;</span>, <span class="built_in">add</span>(i, j));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Static关键字作用&quot;&gt;&lt;a href=&quot;#Static关键字作用&quot; class=&quot;headerlink&quot; title=&quot;Static关键字作用&quot;&gt;&lt;/a&gt;Static关键字作用&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;</summary>
      
    
    
    
    <category term="IT分类" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/"/>
    
    <category term="开发杂记" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/%E5%BC%80%E5%8F%91%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://aixuek-itshare.com/tags/C/"/>
    
    <category term="Code" scheme="https://aixuek-itshare.com/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>开发杂记</title>
    <link href="https://aixuek-itshare.com/it-categories/dev-record/index/"/>
    <id>https://aixuek-itshare.com/it-categories/dev-record/index/</id>
    <published>2024-06-28T07:44:36.000Z</published>
    <updated>2024-08-24T14:26:51.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发杂记"><a href="#开发杂记" class="headerlink" title="开发杂记"></a>开发杂记</h1><h2 id="C-笔记"><a href="#C-笔记" class="headerlink" title="C++笔记"></a><a href="https://aixuek-itshare.com/it-categories/dev-record/C++-notes">C++笔记</a></h2><h2 id="指针vs引用"><a href="#指针vs引用" class="headerlink" title="指针vs引用"></a><a href="https://aixuek-itshare.com/it-categories/dev-record/pointer-and-reference">指针vs引用</a></h2><h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a><a href="https://aixuek-itshare.com/it-categories/dev-record/copy-constructor">复制构造函数</a></h2><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a><a href="https://aixuek-itshare.com/it-categories/dev-record/func-pointer">函数指针</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开发杂记&quot;&gt;&lt;a href=&quot;#开发杂记&quot; class=&quot;headerlink&quot; title=&quot;开发杂记&quot;&gt;&lt;/a&gt;开发杂记&lt;/h1&gt;&lt;h2 id=&quot;C-笔记&quot;&gt;&lt;a href=&quot;#C-笔记&quot; class=&quot;headerlink&quot; title=&quot;C++笔记&quot;&gt;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++面试问题</title>
    <link href="https://aixuek-itshare.com/it-categories/interviews/C++-interview-questions/"/>
    <id>https://aixuek-itshare.com/it-categories/interviews/C++-interview-questions/</id>
    <published>2024-06-28T02:45:05.000Z</published>
    <updated>2024-08-24T14:26:51.804Z</updated>
    
    
    
    
    <category term="IT分类" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/"/>
    
    <category term="面试过往" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/%E9%9D%A2%E8%AF%95%E8%BF%87%E5%BE%80/"/>
    
    
    <category term="C++" scheme="https://aixuek-itshare.com/tags/C/"/>
    
    <category term="Interview" scheme="https://aixuek-itshare.com/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>前缀和与差分</title>
    <link href="https://aixuek-itshare.com/it-categories/code-prac/prefix-sum/"/>
    <id>https://aixuek-itshare.com/it-categories/code-prac/prefix-sum/</id>
    <published>2024-06-26T13:31:50.000Z</published>
    <updated>2024-08-24T14:26:51.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><p>主要思想：</p><ol><li>求[l, r] l到r之间的和，比方说从第二个到五个数的总和可以表示为，前5个数的总和减去前一个数的总和：<code>s[l~r] = s[r] - s[l - 1]</code>，s为到第i个数的总和</li><li>默认s[0] = 0,来统一计算方式（节省了个if）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><p>问题：求二维数组一块区域的前缀和</p><p>若要计算$s<em>{x2_y2}$到$s</em>{x1_y1}$, 就要减去俩个长方形的，然后加上重复减去的长方形的前缀和: </p><script type="math/tex; mode=display">s_{x2_y2}到s_{x1_y1} = s_{x2_y2} - s_{x2_y0} - s_{x0_y2} + s_{x1_y1} (边界记得-1)</script><p><img src="/images/it-categories/presum-alg.png" alt="二维前缀和问题演示"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> a[N][N], s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x2][y1<span class="number">-1</span>] - s[x1<span class="number">-1</span>][y2] + s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>主要思想：</p><p>构造b1, b2, b3…, bn，使得a数组为b数组的前缀和：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ai = b1 + b2 + ... + bi \\</span><br><span class="line">b1 = a1 \\</span><br><span class="line">b2 = a2 - a1 \\</span><br><span class="line">bn = an - a_(n-1)</span><br></pre></td></tr></table></figure><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><p>用处：</p><p>这样可以通过求b数组的前缀和来得到a数组， 对于要求对于区间[r, l]中a+c，但其他a的值不变，想求改变之后a总共的和就只需要改变$b<em>l$和$b</em>{r+1}$的值 (O(1))，而不需要循环一边全部加上C（O(n)）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a_l -&gt; b_l + c \\</span><br><span class="line">a_&#123;r+1&#125; -&gt; b_&#123;r+1&#125; - c  （抵消之前加的c）</span><br></pre></td></tr></table></figure></p><p>题目：</p><p>输入一个长度为n的整数序列，接下来输入m个操作，每个操作包含三个整数l, r, c，表示将列序中[l, r]之间的每个数都加上c。</p><p>输出进行完所有操作之后的序列</p><details>    <summary>代码示例</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100006</span>;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">insert</span>(i, i, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(l, r, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        b[i] += b[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><p>主要思想：</p><p>如下图，在二维数组中，仅让x_1, y_1到x_2, y_2的点之间的数加一个数C。这时可用差分来仅改变四个数的值来求一次和，而不用每次都遍历求和</p><p><img src="/images/it-categories/difference-alg.png" alt="二维差分示意图"></p><p>题目：</p><p>第一行包含整数 n,m,q，接下来 n 行，每行包含 m 个整数，表示整数矩阵。接下来 q 行，每行包含 5 个整数 x1,y1,x2,y2,c，表示一个操作。</p><p>要求输出：共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。</p><p>代码解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">insert</span>(i, j, i, j, a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(x1, y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前缀和&quot;&gt;&lt;a href=&quot;#前缀和&quot; class=&quot;headerlink&quot; title=&quot;前缀和&quot;&gt;&lt;/a&gt;前缀和&lt;/h1&gt;&lt;h2 id=&quot;一维前缀和&quot;&gt;&lt;a href=&quot;#一维前缀和&quot; class=&quot;headerlink&quot; title=&quot;一维前缀和&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="IT分类" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/"/>
    
    <category term="代码刷题" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/%E4%BB%A3%E7%A0%81%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="Code" scheme="https://aixuek-itshare.com/tags/Code/"/>
    
    <category term="Algorithm" scheme="https://aixuek-itshare.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>二分算法</title>
    <link href="https://aixuek-itshare.com/it-categories/code-prac/bisection-alg/"/>
    <id>https://aixuek-itshare.com/it-categories/code-prac/bisection-alg/</id>
    <published>2024-06-24T14:06:31.000Z</published>
    <updated>2024-08-24T14:26:51.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h1><p>本质：</p><ol><li>如果有单调性的话，可以二分；但二分的题目，不一定一定要单调性；所以本质不是单调性</li><li>在一个区间内，我们定义了一个性质，这个性质左半边满足，右半边不满足，可以将区间一分为二；二分可以寻找边界</li></ol><p>主要思想：<br><img src="/images/it-categories/bisection-alg1.png" alt="整数二分思路图示"></p><ol><li><p>以红色区域为True，找分界点（以红色的边界点为分界点）</p><ol><li>找到中间值（mid = (l + r + 1)/2）</li><li><p>查看中间值性质（在左半边还是右半边）：</p><p>  a. [mid, r] mid处于左半边，所以分界点一定处于这里（mid到 r，包括mid）</p><p>  b. [l, mid - 1] mid处于右半边，所以分界点处于左半边 （因 此时 r = mid - 1所以mid需要在之前+1来保证它概括到红色右边 界：mid = (l + r <strong>+ 1</strong>) / 2， 且当情况为 l = r - 1 时，l经过操作还是 l = (l + r) / 2向下取整，还是l，死循 环）</p></li></ol></li><li><p>以绿色区域为True（以绿色的边界点为分界点）</p><ol><li>mid = (l + r ) / 2</li><li><p>查看中间值性质</p><p> a. [l, mid], inclusive</p><p> b. [mid + 1, r] 因mid为False，所以一定从mid + 1开始 （此时 l = mid + 1, 所以mid原本要保证在floor：<strong>mid = (l + r) / 1</strong>，这样让它能概括到右半边的左边界）</p></li></ol></li></ol><details>    <summary>Code</summary>题目（Acwing 789）找到sorted数组中的数的起始和终止位置，若没有这个数，便返回-1, -1输入：数组长度，询问个数，数组<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找到起始值</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 要满足的条件是左边&lt;x，右边&gt;=x，就是找绿色区域</span></span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &gt;= x)</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若第一个&gt;=x的值不为x，即x不存在于数组</span></span><br><span class="line">        <span class="keyword">if</span> (q[l] != x)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 找终止值</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 要满足的条件是：左边&lt;=x,右边&gt;x，即找红色区域</span></span><br><span class="line">                <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[mid] &lt;= x)</span><br><span class="line">                    l = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h1><p>主要思想和<strong>整数二分</strong>一致，但不用考虑边界问题</p><details>    <summary> Code </summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> l = <span class="number">0</span>, r = x;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1e-6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mid * mid &gt;= x)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;整数二分&quot;&gt;&lt;a href=&quot;#整数二分&quot; class=&quot;headerlink&quot; title=&quot;整数二分&quot;&gt;&lt;/a&gt;整数二分&lt;/h1&gt;&lt;p&gt;本质：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果有单调性的话，可以二分；但二分的题目，不一定一定要单调性；所以本质不是单调性&lt;/li&gt;</summary>
      
    
    
    
    <category term="IT分类" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/"/>
    
    <category term="代码刷题" scheme="https://aixuek-itshare.com/categories/IT%E5%88%86%E7%B1%BB/%E4%BB%A3%E7%A0%81%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="Code" scheme="https://aixuek-itshare.com/tags/Code/"/>
    
    <category term="Algorithm" scheme="https://aixuek-itshare.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>代码刷题</title>
    <link href="https://aixuek-itshare.com/it-categories/code-prac/index/"/>
    <id>https://aixuek-itshare.com/it-categories/code-prac/index/</id>
    <published>2024-06-24T14:06:31.000Z</published>
    <updated>2024-08-24T14:26:51.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码刷题"><a href="#代码刷题" class="headerlink" title="代码刷题"></a>代码刷题</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a><a href="https://aixuek-itshare.com/it-categories/code-prac/sort-alg">排序算法</a></h2><h2 id="二分算法"><a href="#二分算法" class="headerlink" title="二分算法"></a><a href="https://aixuek-itshare.com/it-categories/code-prac/bisection-alg">二分算法</a></h2><h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a><a href="https://aixuek-itshare.com/it-categories/code-prac/prefix-sum">前缀和与差分</a></h2><h2 id="C-面试准备"><a href="#C-面试准备" class="headerlink" title="C++面试准备"></a><a href="https://aixuek-itshare.com/it-categories/code-prac/C++-interview-prepare">C++面试准备</a></h2><h2 id="DFS和BFS"><a href="#DFS和BFS" class="headerlink" title="DFS和BFS"></a><a href="https://aixuek-itshare.com/it-categories/code-prac/dfs-bfs">DFS和BFS</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;代码刷题&quot;&gt;&lt;a href=&quot;#代码刷题&quot; class=&quot;headerlink&quot; title=&quot;代码刷题&quot;&gt;&lt;/a&gt;代码刷题&lt;/h1&gt;&lt;h2 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>游戏编程</title>
    <link href="https://aixuek-itshare.com/game-categories/gd-tut/index/"/>
    <id>https://aixuek-itshare.com/game-categories/gd-tut/index/</id>
    <published>2024-06-24T14:06:31.000Z</published>
    <updated>2024-10-24T13:09:38.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏编程"><a href="#游戏编程" class="headerlink" title="游戏编程"></a>游戏编程</h1><h2 id="SFML-C-项目"><a href="#SFML-C-项目" class="headerlink" title="SFML C++ 项目"></a><a href="https://aixuek-itshare.com/game-categories/gd-tut/SFML-project">SFML C++ 项目</a></h2><h2 id="5-3-2-UE-build报错"><a href="#5-3-2-UE-build报错" class="headerlink" title="5.3.2 UE build报错"></a><a href="https://aixuek-itshare.com/game-categories/gd-tut/5.3.2-build-error">5.3.2 UE build报错</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;游戏编程&quot;&gt;&lt;a href=&quot;#游戏编程&quot; class=&quot;headerlink&quot; title=&quot;游戏编程&quot;&gt;&lt;/a&gt;游戏编程&lt;/h1&gt;&lt;h2 id=&quot;SFML-C-项目&quot;&gt;&lt;a href=&quot;#SFML-C-项目&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
  </entry>
  
</feed>
